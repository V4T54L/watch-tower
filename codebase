{
  "cmd/consumer/main.go": "package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n\n\t\"github.com/user/log-ingestor/internal/pkg/config\"\n\t\"github.com/user/log-ingestor/internal/pkg/logger\"\n)\n\nfunc main() {\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tslog.Error(\"failed to load configuration\", \"error\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlog := logger.New(cfg.LogLevel)\n\tlog.Info(\"starting consumer worker...\")\n\n\t// TODO: Initialize and run consumer logic\n\t// - Connect to Redis\n\t// - Start consumer group processing loop\n\t// - Connect to PostgreSQL\n\t// - Setup signal handling for graceful shutdown\n\n\tlog.Info(\"consumer worker stopped\")\n}\n",
  "cmd/ingest/main.go": "package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n\n\t\"github.com/user/log-ingestor/internal/pkg/config\"\n\t\"github.com/user/log-ingestor/internal/pkg/logger\"\n)\n\nfunc main() {\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tslog.Error(\"failed to load configuration\", \"error\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlog := logger.New(cfg.LogLevel)\n\tlog.Info(\"starting ingest gateway...\")\n\n\t// TODO: Initialize and run ingest server\n\t// - Initialize repositories (Redis, WAL, PostgreSQL for API keys)\n\t// - Initialize use cases\n\t// - Setup HTTP router and handlers\n\t// - Start HTTP server\n\t// - Setup signal handling for graceful shutdown\n\n\tlog.Info(\"ingest gateway stopped\")\n}\n",
  "go.mod": "module github.com/user/log-ingestor\n\ngo 1.21\n\nrequire (\n\tgithub.com/caarlos0/env/v10 v10.0.0\n\tgithub.com/joho/godotenv v1.5.1\n)\n",
  "internal/domain/log.go": "package domain\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\n// LogEvent represents the canonical structure of a log event within the system.\ntype LogEvent struct {\n\tID          string          `json:\"event_id\"`\n\tReceivedAt  time.Time       `json:\"received_at\"`\n\tEventTime   time.Time       `json:\"event_time\"`\n\tSource      string          `json:\"source,omitempty\"`\n\tLevel       string          `json:\"level,omitempty\"`\n\tMessage     string          `json:\"message\"`\n\tMetadata    json.RawMessage `json:\"metadata,omitempty\"`\n\tRawEvent    json.RawMessage `json:\"-\"` // The original raw event, not marshalled to the final sink\n\tPIIRedacted bool            `json:\"pii_redacted,omitempty\"`\n}\n",
  "internal/domain/repository.go": "package domain\n\nimport \"context\"\n\n// LogRepository defines the interface for buffering and sinking log events.\n// This abstracts away the specific implementations (e.g., Redis Streams, PostgreSQL).\ntype LogRepository interface {\n\t// BufferLog adds a single log event to the durable buffer.\n\tBufferLog(ctx context.Context, event LogEvent) error\n\n\t// ReadLogBatch reads a batch of log events from the buffer for a specific consumer.\n\tReadLogBatch(ctx context.Context, group, consumer string, count int) ([]LogEvent, error)\n\n\t// WriteLogBatch writes a batch of log events to the final structured sink.\n\tWriteLogBatch(ctx context.Context, events []LogEvent) error\n\n\t// AcknowledgeLogs marks a set of log events as successfully processed in the buffer.\n\tAcknowledgeLogs(ctx context.Context, group string, eventIDs ...string) error\n}\n\n// APIKeyRepository defines the interface for validating API keys.\ntype APIKeyRepository interface {\n\t// IsValid checks if the provided API key is valid and active.\n\t// Implementations should handle caching to reduce database load.\n\tIsValid(ctx context.Context, key string) (bool, error)\n}\n\n// WALRepository defines the interface for the Write-Ahead Log failover mechanism.\ntype WALRepository interface {\n\t// Write appends a log event to the local WAL file.\n\tWrite(ctx context.Context, event LogEvent) error\n\n\t// Replay reads events from the WAL and sends them to a handler function.\n\t// The handler is responsible for re-buffering the event (e.g., to Redis).\n\tReplay(ctx context.Context, handler func(event LogEvent) error) error\n\n\t// Truncate removes WAL segments that have been successfully replayed.\n\tTruncate(ctx context.Context) error\n}\n",
  "internal/pkg/config/config.go": "package config\n\nimport (\n\t\"time\"\n\n\t\"github.com/caarlos0/env/v10\"\n\t\"github.com/joho/godotenv\"\n)\n\n// Config holds all configuration for the application, loaded from environment variables.\ntype Config struct {\n\tLogLevel       string `env:\"LOG_LEVEL\" envDefault:\"info\"`\n\tMaxEventSize   int64  `env:\"MAX_EVENT_SIZE_BYTES\" envDefault:\"1048576\"` // 1MB\n\tWALSegmentSize int64  `env:\"WAL_SEGMENT_SIZE_BYTES\" envDefault:\"104857600\"` // 100MB\n\tWALMaxDiskSize int64  `env:\"WAL_MAX_DISK_SIZE_BYTES\" envDefault:\"1073741824\"` // 1GB\n\n\t// BackpressurePolicy defines how the ingest API behaves when internal buffers are full.\n\t// Supported values: \"block\", \"429\", \"drop\".\n\tBackpressurePolicy string `env:\"BACKPRESSURE_POLICY\" envDefault:\"429\"`\n\n\t// Redis configuration\n\tRedisAddr string `env:\"REDIS_ADDR,required\"`\n\n\t// PostgreSQL configuration\n\tPostgresURL string `env:\"POSTGRES_URL,required\"`\n\n\t// API Key Cache configuration\n\tAPIKeyCacheTTL time.Duration `env:\"API_KEY_CACHE_TTL\" envDefault:\"5m\"`\n}\n\n// Load parses environment variables into the Config struct.\n// It also loads a .env file if it exists, for local development.\nfunc Load() (*Config, error) {\n\t// Load .env file if it exists. This is useful for local development.\n\t// In production, environment variables should be set directly.\n\t_ = godotenv.Load()\n\n\tcfg := \u0026Config{}\n\tif err := env.Parse(cfg); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cfg, nil\n}\n",
  "internal/pkg/logger/logger.go": "package logger\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n\t\"strings\"\n)\n\n// New creates and configures a new slog.Logger.\nfunc New(level string) *slog.Logger {\n\tvar logLevel slog.Level\n\n\tswitch strings.ToLower(level) {\n\tcase \"debug\":\n\t\tlogLevel = slog.LevelDebug\n\tcase \"info\":\n\t\tlogLevel = slog.LevelInfo\n\tcase \"warn\", \"warning\":\n\t\tlogLevel = slog.LevelWarn\n\tcase \"error\":\n\t\tlogLevel = slog.LevelError\n\tdefault:\n\t\tlogLevel = slog.LevelInfo\n\t}\n\n\topts := \u0026slog.HandlerOptions{\n\t\tLevel: logLevel,\n\t}\n\n\thandler := slog.NewJSONHandler(os.Stdout, opts)\n\tlogger := slog.New(handler)\n\n\treturn logger\n}\n```"
}